{"version":3,"sources":["webpack://theia_waffle_nano_burn/webpack/bootstrap","webpack://theia_waffle_nano_burn/external \"theia.theia_waffle_nano_burn\"","webpack://theia_waffle_nano_burn/external \"wm.theia_waffle_nano_burn\"","webpack://theia_waffle_nano_burn/./src/waffle-nano-burn-frontend.ts","webpack://theia_waffle_nano_burn/./src/hiburn.ts","webpack://theia_waffle_nano_burn/./src/firmware.ts","webpack://theia_waffle_nano_burn/./src/fileSystemAdaptor.ts","webpack://theia_waffle_nano_burn/./src/ymodem.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","theia","theia_waffle_nano_burn","wm","commands","id","label","hiburn","Hiburn","context","subscriptions","push","registerCommand","args","fsPath","webserial","connected","uri","Uri","parse","uploadFirmware","setBreak","Burn","FrameType","readMode","START_FLAG","Uint8Array","ACK_FRAME","YMODEM_START_ACK","YMODEM_START_ACK_255","YMODEM_ACK","actionLock","this","NONE","readOkFlag","breakFlag","ymodem","Ymodem","l1","l2","join","indexOf","clearData","readData","setInterval","data","onData","length","dataList","values","concat","BURN_ACK","checkSubList","YMODEM_START","YMODEM","clearInterval","crc","index","byteLength","code","frame","frameNoCrc","Data","set","Start_flag","Packet_size","Frame_type","Frame_type_reverse","crc16_xmodem","reverse","frameWithCrc","frameType","frameLength","reverseUint8","frame2Uint8","time","Promise","resolve","setTimeout","fileAddr","fileLength","eraseSize","generateFrame","Command_Download_FLASH_image","writeListData","Array","from","sleep","Command_Reset","file","header","generateHeader","fileName","fileSize","datas","generateBody","fileData","dialog","processBar","setPercent","Number","generateEnd","baudRate","console","log","Shake_hands_frame","disconnect","openSerialPort","dataBits","stopBits","parity","bufferSize","flowControl","firmware","Firmware","readFile","files","startReadData","type","message","open","setContent","closeButtom","startLoader","undefined","reconnect","close","removeCloseButtom","setTitle","requestUpload","burnAddr","burnSize","sendFile","sendReboot","stopReadData","FirmwareHeader","textDecoder","TextDecoder","FileHeaderStarter","File","fileIndex","_uri","_fileData","FileSystemAdaptor","_fileSize","getFileSize","decodeBin","num","first","subarray","second","every","_fileNum","fileHeaderStart","decode","filter","decodeBuffer2Num","untitledDocumentData","scheme","workspace","fs","stat","size","START","encoder","TextEncoder","Start","PacketNum","RPacketNum","Crc","nameBuffer","encode","sizeBuffer","toString","zeroBuffer","frame2Buffer","dataLength","Math","floor","dataBuffer"],"mappings":"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","file":"waffle-nano-burn-frontend.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = theia.theia_waffle_nano_burn;","module.exports = wm.theia_waffle_nano_burn;","import * as theia from '@theia/plugin';\nimport { webserial } from \"@wm/plugin\";\nimport { Hiburn } from \"./hiburn\";\n\nconst commands = {\n    burnUploadCommand: {\n        id: \"waffle.nano.burn.upload\",\n        label: \"waffle nano:upload\"\n    },\n    burnBreakCommand: {\n        id: \"waffle.nano.burn.break\",\n        label: \"waffle nano:break\",\n    }\n}\n\nconst baudRate = 921600;\nconst hiburn: Hiburn = new Hiburn();\n\nexport function start(context: theia.PluginContext) {\n    context.subscriptions.push(\n        theia.commands.registerCommand(commands.burnUploadCommand, async (...args: any[]) => {\n            if (args[0]?.fsPath && webserial.connected()) {\n                let uri = theia.Uri.parse(args[0].fsPath);\n                await hiburn.uploadFirmware(uri, baudRate);\n            }\n        })\n    );\n\n    context.subscriptions.push(\n        theia.commands.registerCommand(commands.burnBreakCommand, async (...args: any) => {\n            hiburn.setBreak();\n        })\n    );\n}\n\nexport function stop() {\n\n}\n","import { Uri } from \"@theia/plugin\";\nimport { webserial, dialog } from \"@wm/plugin\";\nimport { File, Firmware } from \"./firmware\";\nimport { Ymodem } from \"./ymodem\";\n\nexport namespace Burn {\n    export const START_FLAG: Uint8Array = new Uint8Array([0xEF, 0xBE, 0xAD, 0xDE]);\n\n    export interface Frame {\n        Start_flag: Uint8Array;\n        Packet_size: Uint8Array;\n        Frame_type: Uint8Array;\n        Frame_type_reverse: Uint8Array;\n        Data: Uint8Array;\n        Check_sum?: Uint8Array;\n    }\n\n    export enum FrameType {\n        Shake_hands_frame = 240,\n        ACK_frame = 225,\n        Command_Download_FLASH_image = 210,\n        Command_Download_OTP = 195,\n        Command_Upload_data = 180,\n        Command_Read_OTP = 165,\n        Command_Flash_Protection = 150,\n        Command_Reset = 135,\n        Command_Download_Factory_bin = 120,\n        Command_Download_Version = 105,\n        Command_Download_NVKV_configuration = 75,\n    }\n\n    export enum readMode {\n        NONE,\n        BURN_ACK,\n        YMODEM_START,\n        YMODEM,\n    }\n\n    export const ACK_FRAME: number[] = [239, 190, 173, 222, 12, 0, 225, 30, 90, 66, 19, 74];\n    export const YMODEM_START_ACK: number[] = [67];\n    export const YMODEM_START_ACK_255: number[] = [255];\n    export const YMODEM_ACK: number[] = [6];\n}\n\nconst dataChannel = \"waffle-nano-burn\";\n\nexport class Hiburn {\n    private readData: any;\n    private readMode: Burn.readMode;\n    private readOkFlag: boolean;\n    private breakFlag: boolean;\n    actionLock: boolean = false;\n    private ymodem: Ymodem;\n\n    constructor() {\n        this.readMode = Burn.readMode.NONE;\n        this.readOkFlag = true;\n        this.breakFlag = false;\n        this.actionLock = false;\n        this.ymodem = new Ymodem();\n    }\n\n    private static checkSubList(l1: number[], l2: number[]): boolean {\n        return !!~l2.join('').indexOf(l1.join(''));\n    }\n\n    private async startReadData() {\n        await webserial.clearData(dataChannel);\n        this.readData = setInterval(async () => {\n            let data = await webserial.onData(dataChannel) as any;\n            if (data.length > 0) {\n                let dataList: number[] = [];\n                for (let values of data) {\n                    dataList = dataList.concat(Object.values(values));\n                }\n                // console.log(this.readMode);\n                // console.log(dataList);\n                switch (this.readMode) {\n                    case Burn.readMode.NONE:\n                        break;\n                    case Burn.readMode.BURN_ACK:\n                        if (Hiburn.checkSubList(Burn.ACK_FRAME, dataList)) {\n                            this.readOkFlag = true;\n                        }\n                        break;\n                    case Burn.readMode.YMODEM_START:\n                        if (Burn.YMODEM_START_ACK[0] === dataList[0]) {\n                            this.readOkFlag = true;\n                        }\n                        break;\n                    case Burn.readMode.YMODEM:\n                        if (Burn.YMODEM_ACK[0] === dataList[0]) {\n                            this.readOkFlag = true;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }, 40);\n    }\n\n    private async stopReadData() {\n        clearInterval(this.readData);\n    }\n\n    protected crc16_xmodem(data: Uint8Array): Uint8Array {\n        let crc = 0x00;\n        for (let index = 0; index < data.byteLength; index++) {\n            const byte = data[index];\n            let code = (crc >>> 8) & 0xff;\n\n            code ^= byte & 0xff;\n            code ^= code >>> 4;\n            crc = (crc << 8) & 0xffff;\n            crc ^= code;\n            code = (code << 5) & 0xffff;\n            crc ^= code;\n            code = (code << 7) & 0xffff;\n            crc ^= code;\n        }\n\n        return new Uint8Array([crc >> 8, crc & 0xFF]);\n    }\n\n    protected reverseUint8(data: number): number {\n        return ((data & 0x01) << 7) | ((data & 0x02) << 5) | ((data & 0x04) << 3) | ((data & 0x08) << 1) |\n            ((data & 0x10) >> 1) | ((data & 0x20) >> 3) | ((data & 0x40) >> 5) | ((data & 0x80) >> 7);\n    }\n\n    private frame2Uint8(frame: Burn.Frame): Uint8Array {\n        let frameNoCrc = new Uint8Array(frame.Data.byteLength + 8);\n        frameNoCrc.set(frame.Start_flag, 0);\n        frameNoCrc.set(frame.Packet_size, 4);\n        frameNoCrc.set(frame.Frame_type, 6);\n        frameNoCrc.set(frame.Frame_type_reverse, 7);\n        frameNoCrc.set(frame.Data, 8);\n        let crc = this.crc16_xmodem(frameNoCrc).reverse();\n        let frameWithCrc = new Uint8Array(frameNoCrc.byteLength + 2);\n        frameWithCrc.set(frameNoCrc, 0);\n        frameWithCrc.set(crc, frameNoCrc.byteLength);\n        return frameWithCrc;\n    }\n\n    private generateFrame(frameType: Burn.FrameType, data: Uint8Array): Uint8Array {\n        let frameLength = data.byteLength + 10;\n        let frame: Burn.Frame = {\n            Start_flag: Burn.START_FLAG,\n            Packet_size: new Uint8Array([frameLength >> 8, frameLength & 0xff]).reverse(),\n            Frame_type: new Uint8Array([frameType]),\n            Frame_type_reverse: new Uint8Array([this.reverseUint8(frameType)]),\n            Data: data,\n        };\n        return this.frame2Uint8(frame);\n    }\n\n    private async sleep(time: number) {\n        return new Promise((resolve) => setTimeout(resolve, time));\n    }\n\n    private async requestUpload(fileAddr: number, fileLength: number, eraseSize: number) {\n        let data = [\n            fileAddr & 0xFF,\n            (fileAddr >> 8) & 0xFF,\n            (fileAddr >> 16) & 0xFF,\n            (fileAddr >> 24) & 0xFF,\n            fileLength & 0xFF,\n            (fileLength >> 8) & 0xFF,\n            (fileLength >> 16) & 0xFF,\n            (fileLength >> 24) & 0xFF,\n            eraseSize & 0xFF,\n            (eraseSize >> 8) & 0xFF,\n            (eraseSize >> 16) & 0xFF,\n            (eraseSize >> 24) & 0xFF,\n            0x00,\n            0xFF,\n        ];\n        let frame = this.generateFrame(Burn.FrameType.Command_Download_FLASH_image, new Uint8Array(data));\n        this.readOkFlag = false;\n        this.readMode = Burn.readMode.YMODEM_START;\n        await webserial.writeListData(Array.from(frame));\n        while (!this.readOkFlag) {\n            await this.sleep(40);\n        }\n    }\n\n    private async sendReboot() {\n        let data = [0x00, 0x00];\n        let frame = this.generateFrame(Burn.FrameType.Command_Reset, new Uint8Array(data));\n        await webserial.writeListData(Array.from(frame));\n    }\n\n    private async sendFile(file: File) {\n        if (!this.breakFlag) {\n            this.readMode = Burn.readMode.YMODEM_START;\n            this.readOkFlag = false;\n            while (!this.readOkFlag && !this.breakFlag) {\n                await this.sleep(40);\n            }\n        }\n\n        if (!this.breakFlag) {\n            this.readMode = Burn.readMode.YMODEM;\n            let header = this.ymodem.generateHeader(file.fileName, file.fileSize);\n            this.readOkFlag = false;\n            await webserial.writeListData(Array.from(header));\n            while (!this.readOkFlag && !this.breakFlag) {\n                await this.sleep(40);\n            }\n        }\n\n        let datas = this.ymodem.generateBody(file.fileData);\n        for (let i in datas) {\n            dialog.processBar.setPercent(Number(i) / datas.length);\n            if (this.breakFlag) {\n                break;\n            }\n            this.readOkFlag = false;\n            await webserial.writeListData(Array.from(datas[i]));\n            while (!this.readOkFlag && !this.breakFlag) {\n                await this.sleep(40);\n            }\n        }\n\n        if (!this.breakFlag) {\n            let data = this.ymodem.generateEnd();\n            this.readOkFlag = false;\n            await webserial.writeListData([0x04]);\n            await webserial.writeListData(Array.from(data));\n            while (!this.readOkFlag && !this.breakFlag) {\n                await this.sleep(40);\n            }\n        }\n    }\n\n    private async startLoader(baudRate: number) {\n        console.log(baudRate);\n        let data = [\n            // 115200\n            baudRate & 0xff,\n            (baudRate >> 8) & 0xff,\n            (baudRate >> 16) & 0xff,\n            (baudRate >> 24) & 0xff,\n            0x08,\n            0x01,\n            0x00,\n            0x00,\n        ];\n        this.readOkFlag = false;\n        this.readMode = Burn.readMode.BURN_ACK;\n        let frame = this.generateFrame(Burn.FrameType.Shake_hands_frame, new Uint8Array(data));\n        while (!this.readOkFlag && !this.breakFlag) {\n            await webserial.writeListData(Array.from(frame));\n            await this.sleep(2);\n        }\n        this.readMode = Burn.readMode.NONE;\n    }\n\n    private async reconnect(baudRate: number) {\n        await webserial.disconnect();\n        await this.sleep(1000);\n        await webserial.openSerialPort({\n            baudRate: baudRate,\n            dataBits: 8,\n            stopBits: 1,\n            parity: \"none\",\n            bufferSize: 2048,\n            flowControl: \"none\",\n        });\n    }\n\n    public async uploadFirmware(uri: Uri, baudRate?: number) {\n        let firmware = new Firmware(uri);\n        await firmware.readFile();\n\n        if (firmware?.files) {\n            await this.startReadData();\n\n            for (let i in firmware.files) {\n                switch (firmware.files[i].type) {\n                    case 0:\n                        dialog.message.open();\n                        dialog.message.setContent(\"Please reboot your waffle\");\n                        dialog.message.closeButtom();\n                        await this.startLoader(baudRate === undefined ? 115200 : baudRate);\n                        await this.reconnect(baudRate === undefined ? 115200 : baudRate);\n                        dialog.message.close();\n                        dialog.processBar.open(\"nyan\");\n                        dialog.processBar.removeCloseButtom();\n                        dialog.processBar.setTitle(\"Burning\");\n                        break;\n                    case 1:\n                        await this.requestUpload(\n                            firmware.files[i].burnAddr,\n                            firmware.files[i].fileSize,\n                            firmware.files[i].burnSize,\n                        );\n                        break;\n                    default:\n                        break;\n                }\n                if (!this.breakFlag) {\n                    await this.sendFile(firmware.files[i]);\n                }\n            }\n            dialog.processBar.close();\n            await this.sendReboot();\n            await this.reconnect(115200);\n            await this.stopReadData();\n        }\n    }\n\n    public setBreak() {\n        if (!this.breakFlag) {\n            this.breakFlag = true;\n        }\n    }\n}\n","import { Uri } from \"@theia/plugin\";\nimport { FileSystemAdaptor } from \"./fileSystemAdaptor\";\n\nconst FirmwareHeader: Uint8Array = new Uint8Array([223, 173, 190, 239]);\nconst textDecoder: TextDecoder = new TextDecoder();\nconst FileHeaderStarter = {\n    FileName: 32,\n    FileIndex: 36,\n    FileSize: 40,\n    BurnAddr: 44,\n    BurnSize: 48,\n    Type: 52,\n}\nconst arrayEqual = (first: Uint8Array, second: Uint8Array) =>\n    first.length === second.length && first.every((value, index) => value === second[index]);\n\nexport class File {\n    fileName: string;\n    fileIndex: number;\n    fileSize: number;\n    burnAddr: number;\n    burnSize: number;\n    type: number;\n    fileData: Uint8Array;\n\n    constructor(\n        fileName: string,\n        fileIndex: number,\n        fileSize: number,\n        burnAddr: number,\n        burnSize: number,\n        type: number,\n        fileData: Uint8Array,\n    ) {\n        this.fileName = fileName;\n        this.fileIndex = fileIndex;\n        this.fileSize = fileSize;\n        this.burnAddr = burnAddr;\n        this.burnSize = burnSize;\n        this.type = type;\n        this.fileData = fileData;\n    }\n}\n\nexport class Firmware {\n    private readonly _uri: Uri;\n\n    private _fileSize?: number;\n    private _fileData?: Uint8Array;\n    private _fileNum?: number;\n    files?: File[];\n\n    constructor(\n        uri: Uri,\n    ) {\n        this._uri = uri;\n    }\n\n    public async readFile() {\n        this.files = []\n        this._fileData = await FileSystemAdaptor.readFile(this._uri);\n        this._fileSize = await FileSystemAdaptor.getFileSize(this._uri);\n        console.log(this._fileSize);\n        await this.decodeBin()\n    }\n\n    private decodeBuffer2Num(data: Uint8Array): number {\n        let num = 0;\n        for (let i = 0; i < data.byteLength; i++) {\n            num = num << 8 | data[i];\n        }\n        return num;\n    }\n\n    private async decodeBin() {\n        if (this?._fileData) {\n            if (arrayEqual(this._fileData.subarray(0, 4), FirmwareHeader)) {\n                this._fileNum = this._fileData[6];\n                for (let i = 0; i < this._fileNum; i++) {\n                    let fileHeaderStart = i * 52 + 12;\n                    let fileName = textDecoder.decode(\n                        this._fileData.subarray(fileHeaderStart, fileHeaderStart + FileHeaderStarter.FileName)\n                            .filter((data) => {\n                                return data !== 0x00;\n                            })\n                    );\n                    let fileIndex = this.decodeBuffer2Num(this._fileData.subarray(fileHeaderStart + FileHeaderStarter.FileName, fileHeaderStart + FileHeaderStarter.FileIndex).reverse());\n                    let fileSize = this.decodeBuffer2Num(this._fileData.subarray(fileHeaderStart + FileHeaderStarter.FileIndex, fileHeaderStart + FileHeaderStarter.FileSize).reverse());\n                    let burnAddr = this.decodeBuffer2Num(this._fileData.subarray(fileHeaderStart + FileHeaderStarter.FileSize, fileHeaderStart + FileHeaderStarter.BurnAddr).reverse());\n                    let burnSize = this.decodeBuffer2Num(this._fileData.subarray(fileHeaderStart + FileHeaderStarter.BurnAddr, fileHeaderStart + FileHeaderStarter.BurnSize).reverse());\n                    let type = this.decodeBuffer2Num(this._fileData.subarray(fileHeaderStart + FileHeaderStarter.BurnSize, fileHeaderStart + FileHeaderStarter.Type).reverse());\n\n                    let fileData = this._fileData.subarray(fileIndex, fileIndex + fileSize);\n\n                    let file = new File(\n                        fileName,\n                        fileIndex,\n                        fileSize,\n                        burnAddr,\n                        burnSize,\n                        type,\n                        fileData\n                    );\n                    this.files?.push(file);\n                }\n            }\n        }\n    }\n}\n","import * as theia from \"@theia/plugin\";\n\nexport abstract class FileSystemAdaptor {\n\n    /**\n     * @description Calculates the size of the document associated with the uri passed in\n     * @param uri The uri\n     * @returns The file size\n     */\n    public static async getFileSize(uri: theia.Uri, untitledDocumentData?: Uint8Array): Promise<number> {\n        if (uri.scheme === \"untitled\") {\n            return untitledDocumentData?.length ?? 0;\n        } else {\n            return (await theia.workspace.fs.stat(uri)).size;\n        }\n    }\n\n    public static async readFile(uri: theia.Uri, untitledDocumentData?: Uint8Array): Promise<Uint8Array> {\n        // console.log(uri);\n        if (uri.scheme === \"untitled\") {\n            // We have the bytes so we return them\n            return untitledDocumentData ?? new Uint8Array();\n        } else {\n            return theia.workspace.fs.readFile(uri);\n        }\n    }\n}\n","const START = {\n    SOH: 0x01,\n    STX: 0x02,\n}\nconst encoder = new TextEncoder();\n\ninterface Frame {\n    Start: number,\n    PacketNum: number,\n    RPacketNum: number,\n    Data: Uint8Array,\n    Crc: Uint8Array,\n}\n\nexport class Ymodem {\n    private crc16_xmodem(data: Uint8Array): Uint8Array {\n        let crc = 0x00;\n        for (let index = 0; index < data.byteLength; index++) {\n            const byte = data[index];\n            let code = (crc >>> 8) & 0xff;\n\n            code ^= byte & 0xff;\n            code ^= code >>> 4;\n            crc = (crc << 8) & 0xffff;\n            crc ^= code;\n            code = (code << 5) & 0xffff;\n            crc ^= code;\n            code = (code << 7) & 0xffff;\n            crc ^= code;\n        }\n\n        return new Uint8Array([crc >> 8, crc & 0xFF]);\n    }\n\n    private frame2Buffer(frame: Frame): Uint8Array {\n        return new Uint8Array([\n            frame.Start,\n            frame.PacketNum,\n            frame.RPacketNum,\n            ...frame.Data,\n            ...frame.Crc,\n        ]);\n    }\n\n    public generateHeader(name: string, size: number): Uint8Array {\n        let nameBuffer: Uint8Array = encoder.encode(name);\n        let sizeBuffer: Uint8Array = encoder.encode(size.toString());\n        let zeroBuffer: Uint8Array = new Uint8Array(128 - nameBuffer.length - sizeBuffer.length - 1);\n        let data = new Uint8Array([\n            ...nameBuffer,\n            0x00,\n            ...sizeBuffer,\n            ...zeroBuffer,\n        ])\n        let frame: Frame = {\n            Start: START.SOH,\n            PacketNum: 0x00,\n            RPacketNum: 0xFF,\n            Data: data,\n            Crc: this.crc16_xmodem(data)\n        };\n        return this.frame2Buffer(frame);\n    }\n\n    public generateBody(file: Uint8Array): Uint8Array[] {\n        let datas: Uint8Array[] = [];\n        let length = file.length;\n        let dataLength = Math.floor(length / 1024);\n        for (let i = 0; i < dataLength; i++) {\n            let data = file.subarray(i * 1024, (i + 1) * 1024);\n            let frame: Frame = {\n                Start: START.STX,\n                PacketNum: i + 1,\n                RPacketNum: 254 - i,\n                Data: data,\n                Crc: this.crc16_xmodem(data)\n            }\n            datas.push(this.frame2Buffer(frame));\n        }\n        let dataBuffer = file.subarray(dataLength * 1024, length);\n        let zeroBuffer: Uint8Array = new Uint8Array(1024 - dataBuffer.length);\n        let data = new Uint8Array([\n            ...dataBuffer,\n            ...zeroBuffer,\n        ]);\n        let frame: Frame = {\n            Start: START.STX,\n            PacketNum: dataLength + 1,\n            RPacketNum: 254 - dataLength,\n            Data: data,\n            Crc: this.crc16_xmodem(data),\n        }\n        datas.push(this.frame2Buffer(frame));\n        return datas;\n    }\n\n    public generateEnd(): Uint8Array {\n        let data: Uint8Array = new Uint8Array(128);\n        let frame: Frame = {\n            Start: START.SOH,\n            PacketNum: 0x00,\n            RPacketNum: 0xFF,\n            Data: data,\n            Crc: this.crc16_xmodem(data),\n        };\n        return this.frame2Buffer(frame);\n    }\n}\n"],"sourceRoot":""}